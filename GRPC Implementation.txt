package com.example.grpc.service;

import com.example.grpc.*;
import com.example.grpc.entity.Customer;
import com.example.grpc.repository.CustomerRepository;
import io.grpc.stub.StreamObserver;
import net.devh.boot.grpc.server.service.GrpcService;
import org.springframework.beans.factory.annotation.Autowired;

import java.util.Optional;

@GrpcService
public class CustomerGrpcService extends CustomerServiceGrpc.CustomerServiceImplBase {

    @Autowired
    private CustomerRepository customerRepository;

    // Stream de input/output para salvar múltiplos clientes
    @Override
    public StreamObserver<CustomerModel> saveCustomers(StreamObserver<CustomerModel> responseObserver) {
        return new StreamObserver<CustomerModel>() {
            @Override
            public void onNext(CustomerModel customerModel) {
                Customer customer = new Customer();
                customer.setName(customerModel.getName());
                customer.setLastName(customerModel.getLastName());
                customer.setEmail(customerModel.getEmail());
                customer.setAge(customerModel.getAge());

                Customer savedCustomer = customerRepository.save(customer);

                CustomerModel responseModel = CustomerModel.newBuilder()
                        .setId(savedCustomer.getId())
                        .setName(savedCustomer.getName())
                        .setLastName(savedCustomer.getLastName())
                        .setEmail(savedCustomer.getEmail())
                        .setAge(savedCustomer.getAge())
                        .build();

                responseObserver.onNext(responseModel);
            }

            @Override
            public void onError(Throwable t) {
                t.printStackTrace();
            }

            @Override
            public void onCompleted() {
                responseObserver.onCompleted();
            }
        };
    }

    // Retorna todos os clientes via stream
    @Override
    public void getAllCustomers(Empty request, StreamObserver<CustomerModel> responseObserver) {
        Iterable<Customer> customers = customerRepository.findAll();

        for (Customer customer : customers) {
            CustomerModel customerModel = CustomerModel.newBuilder()
                    .setId(customer.getId())
                    .setName(customer.getName())
                    .setLastName(customer.getLastName())
                    .setEmail(customer.getEmail())
                    .setAge(customer.getAge())
                    .build();

            responseObserver.onNext(customerModel);
        }
        responseObserver.onCompleted();
    }

    // Retorna um cliente por ID
    @Override
    public void getCustomerById(CustomerId request, StreamObserver<CustomerModel> responseObserver) {
        Optional<Customer> customerOpt = customerRepository.findById(request.getId());
        
        if (customerOpt.isPresent()) {
            Customer customer = customerOpt.get();
            CustomerModel customerModel = CustomerModel.newBuilder()
                    .setId(customer.getId())
                    .setName(customer.getName())
                    .setLastName(customer.getLastName())
                    .setEmail(customer.getEmail())
                    .setAge(customer.getAge())
                    .build();
            responseObserver.onNext(customerModel);
        } else {
            responseObserver.onError(new Exception("Customer not found with ID: " + request.getId()));
        }

        responseObserver.onCompleted();
    }

    // Stream de input/output para atualizar múltiplos clientes
    @Override
    public StreamObserver<CustomerModel> putCustomers(StreamObserver<CustomerModel> responseObserver) {
        return new StreamObserver<CustomerModel>() {
            @Override
            public void onNext(CustomerModel customerModel) {
                Optional<Customer> customerOpt = customerRepository.findById(customerModel.getId());

                if (customerOpt.isPresent()) {
                    Customer customer = customerOpt.get();
                    customer.setName(customerModel.getName());
                    customer.setLastName(customerModel.getLastName());
                    customer.setEmail(customerModel.getEmail());
                    customer.setAge(customerModel.getAge());

                    Customer updatedCustomer = customerRepository.save(customer);

                    CustomerModel updatedModel = CustomerModel.newBuilder()
                            .setId(updatedCustomer.getId())
                            .setName(updatedCustomer.getName())
                            .setLastName(updatedCustomer.getLastName())
                            .setEmail(updatedCustomer.getEmail())
                            .setAge(updatedCustomer.getAge())
                            .build();

                    responseObserver.onNext(updatedModel);
                } else {
                    responseObserver.onError(new Exception("Customer not found with ID: " + customerModel.getId()));
                }
            }

            @Override
            public void onError(Throwable t) {
                t.printStackTrace();
            }

            @Override
            public void onCompleted() {
                responseObserver.onCompleted();
            }
        };
    }

    // Deletar clientes via stream de IDs
    @Override
    public StreamObserver<CustomerId> deleteById(StreamObserver<Empty> responseObserver) {
        return new StreamObserver<CustomerId>() {
            @Override
            public void onNext(CustomerId customerId) {
                customerRepository.deleteById(customerId.getId());
            }

            @Override
            public void onError(Throwable t) {
                t.printStackTrace();
            }

            @Override
            public void onCompleted() {
                responseObserver.onNext(Empty.newBuilder().build());
                responseObserver.onCompleted();
            }
        };
    }
}
